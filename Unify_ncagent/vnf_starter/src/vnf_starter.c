
/* 
 * Copyright (c) 2008-2012, Andy Bierman, All Rights Reserved.
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *

*** Generated by yangdump 2.2-5

    Combined SIL module
    module vnf_starter
    revision 2014-05-13
    namespace http://csikor.tmit.bme.hu/netconf/unify/vnf_starter
    organization BME-TMIT

*** Features are implemented by Levente Csikor <csikor@tmit.bme.hu>
    All additions are denoted by
    **************** LEVI ******************
    ...
    ...
    ... additional implementation
    ...
    ...
    ------------ END LEVI ------------------
 */

#include <xmlstring.h>

#include "procdefs.h"
#include "agt.h"
#include "agt_cb.h"
#include "agt_rpc.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "dlq.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "rpc.h"
#include "ses.h"
#include "status.h"
#include "val.h"
#include "val_util.h"
#include "xml_util.h"
#include "vnf_starter.h"

/* module static variables */
static ncx_module_t *vnf_starter_mod;
static obj_template_t *vnf_starter_obj;
static obj_template_t *initiateVNF_obj;
static obj_template_t *connectVNF_obj;
static obj_template_t *disconnectVNF_obj;
static obj_template_t *startVNF_obj;
static obj_template_t *stopVNF_obj;
static obj_template_t *getVNFInfo_obj;
static val_value_t *vnf_starter_val;

/* put your static variables here */
/* -------------- LEVI ---------------- */
static gchar* startup_agent_name = NULL;
static gchar* startup_switch_id = NULL;
static gchar* startup_click_port_min = "8001";  // default: no ports available
static gchar* startup_click_port_max = "8000";  //
static GHashTable* startup_available_vnfs = NULL;
static GSList* available_control_ports = NULL;
/* ------------ END LEVI -------------- */
/********************************************************************
* FUNCTION y_vnf_starter_init_static_vars
* 
* initialize module static variables
* 
********************************************************************/
static void y_vnf_starter_init_static_vars (void)
{
    vnf_starter_mod = NULL;
    vnf_starter_obj = NULL;
    initiateVNF_obj = NULL;
    connectVNF_obj = NULL;
    disconnectVNF_obj = NULL;
    startVNF_obj = NULL;
    stopVNF_obj = NULL;
    getVNFInfo_obj = NULL;
    vnf_starter_val = NULL;

    /* init your static variables here */
    /* -------------- LEVI ---------------- */
       startup_available_vnfs = g_hash_table_new_full (g_str_hash,
                                                       g_str_equal,
                                                       g_free,
                                                       g_free);
       vnf_initializer();
       /* ------------ END LEVI -------------- */
} /* y_vnf_starter_init_static_vars */


/********************************************************************
* FUNCTION vnf_starter_vnf_starter_agent_name_edit
* 
* Edit database object callback
* Path: /vnf_starter/agent_name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t vnf_starter_vnf_starter_agent_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter vnf_starter_vnf_starter_agent_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* vnf_starter_vnf_starter_agent_name_edit */


/********************************************************************
* FUNCTION vnf_starter_vnf_starter_switch_id_edit
* 
* Edit database object callback
* Path: /vnf_starter/switch_id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t vnf_starter_vnf_starter_switch_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter vnf_starter_vnf_starter_switch_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* vnf_starter_vnf_starter_switch_id_edit */


/********************************************************************
* FUNCTION vnf_starter_vnf_starter_click_port_min_edit
* 
* Edit database object callback
* Path: /vnf_starter/click_port_min
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t vnf_starter_vnf_starter_click_port_min_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter vnf_starter_vnf_starter_click_port_min_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* vnf_starter_vnf_starter_click_port_min_edit */


/********************************************************************
* FUNCTION vnf_starter_vnf_starter_click_port_max_edit
* 
* Edit database object callback
* Path: /vnf_starter/click_port_max
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t vnf_starter_vnf_starter_click_port_max_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter vnf_starter_vnf_starter_click_port_max_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* vnf_starter_vnf_starter_click_port_max_edit */


/********************************************************************
* FUNCTION vnf_starter_vnf_starter_available_vnfs_vnf_type_edit
* 
* Edit database object callback
* Path: /vnf_starter/available_vnfs/vnf_type
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t vnf_starter_vnf_starter_available_vnfs_vnf_type_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter vnf_starter_vnf_starter_available_vnfs_vnf_type_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* vnf_starter_vnf_starter_available_vnfs_vnf_type_edit */


/********************************************************************
* FUNCTION vnf_starter_vnf_starter_available_vnfs_vnf_description_edit
* 
* Edit database object callback
* Path: /vnf_starter/available_vnfs/vnf_description
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t vnf_starter_vnf_starter_available_vnfs_vnf_description_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter vnf_starter_vnf_starter_available_vnfs_vnf_description_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* vnf_starter_vnf_starter_available_vnfs_vnf_description_edit */


/********************************************************************
* FUNCTION vnf_starter_vnf_starter_available_vnfs_edit
* 
* Edit database object callback
* Path: /vnf_starter/available_vnfs
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t vnf_starter_vnf_starter_available_vnfs_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    custom_log(LOG, "VNFS_EDIT CALLBACK!");
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter vnf_starter_vnf_starter_available_vnfs_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* vnf_starter_vnf_starter_available_vnfs_edit */


/********************************************************************
* FUNCTION vnf_starter_vnf_starter_edit
* 
* Edit database object callback
* Path: /vnf_starter
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t vnf_starter_vnf_starter_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter vnf_starter_vnf_starter_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }

        if (res == NO_ERR) {
            res = agt_check_cache(&vnf_starter_val, newval, curval, editop);
        }
        
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* vnf_starter_vnf_starter_edit */


/********************************************************************
* FUNCTION y_vnf_starter_initiateVNF_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_vnf_starter_initiateVNF_validate (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode)
{
    status_t res = NO_ERR;
    val_value_t *errorval = NULL;

    val_value_t *vnf_type_val;
    const xmlChar *vnf_type;
    val_value_t *vnf_description_val;
    const xmlChar *vnf_description;
    val_value_t *options_val;
    dlq_hdr_t options;

    vnf_type_val = val_find_child(
        msg->rpc_input,
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_vnf_type);
    if (vnf_type_val != NULL && vnf_type_val->res == NO_ERR) {
        vnf_type = VAL_STRING(vnf_type_val);
    }

    vnf_description_val = val_find_child(
        msg->rpc_input,
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_vnf_description);
    if (vnf_description_val != NULL && vnf_description_val->res == NO_ERR) {
        vnf_description = VAL_STRING(vnf_description_val);
    }

    options_val = val_find_child(
        msg->rpc_input,
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_options);
    if (options_val != NULL && options_val->res == NO_ERR) {
        /* replace the following line with real code to fill in structure */
        (void)options;
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_OPERATION,
            res,
            methnode,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* y_vnf_starter_initiateVNF_validate */


/********************************************************************
* FUNCTION y_vnf_starter_initiateVNF_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_vnf_starter_initiateVNF_invoke (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode)
{
    status_t res = NO_ERR;

    val_value_t *vnf_type_val;
    const xmlChar *vnf_type;
    val_value_t *vnf_description_val;
    const xmlChar *vnf_description;
    val_value_t *options_val;
    dlq_hdr_t options;

    vnf_type_val = val_find_child(
        msg->rpc_input,
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_vnf_type);
    if (vnf_type_val != NULL && vnf_type_val->res == NO_ERR) {
        vnf_type = VAL_STRING(vnf_type_val);
    }

    vnf_description_val = val_find_child(
        msg->rpc_input,
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_vnf_description);
    if (vnf_description_val != NULL && vnf_description_val->res == NO_ERR) {
        vnf_description = VAL_STRING(vnf_description_val);
    }

    options_val = val_find_child(
        msg->rpc_input,
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_options);
    if (options_val != NULL && options_val->res == NO_ERR) {
        /* replace the following line with real code to fill in structure */
        (void)options;
    }

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if methnode is used */
    (void)methnode;

    /* invoke your device instrumentation code here */
    /*********************** LEVI *******************/


    //-------------- setting the vnf's command ----------------
    gchar* vnf_command = g_strdup("");
    //checking the given vnf_type
    if(vnf_type_val != NULL)
    {
        //a vnf_type input was set


        //checking whether for the given vnf_type a preset vnf exists
        if(!g_hash_table_contains(startup_available_vnfs,vnf_type))
        {
            //vnf_type did not exist
            custom_log(WARNING, g_strdup_printf("VNF type %s did not exist",
                                                vnf_type));
            //checking whether vnf_description was set to have a command
            if(vnf_description_val != NULL)
            {
                g_free(vnf_command);
                vnf_command = g_strdup_printf("%s",vnf_description);
                custom_log(INFO, g_strdup_printf("VNF command is %s",
                                                 vnf_command));

            }
            else
            {
                //no vnf_type was found and the vnf_description was not set
                custom_log(ERROR, "I don't know how I will start the VNF :(");
                return ERR_NCX_UNKNOWN_PARM;
            }

        }
        else
        {
            //nothing to do in an else statement, since the  lookup_extended
            //function above returns TRUE then it stores the value assigned to the
            //given key in its 4th param
            g_free(vnf_command);
            vnf_command = g_strdup_printf("%s",
                                          g_hash_table_lookup(
                                                  startup_available_vnfs,
                                                  vnf_type));

            custom_log(INFO, g_strdup_printf("vnf_type %s has the following "
                                             "command %s",
                                             vnf_type,
                                             vnf_command));
        }
    }
    else
    {
        //vnf_type was not set
        //check whether a vnf_description was set
        if(vnf_description_val != NULL)
        {
            //vnf_description was set
            g_free(vnf_command);
            vnf_command = g_strdup_printf("%s",vnf_description);
        }
        else
        {
            //there is no information available how the vnf could be initialized
            //return an RPC ERROR
            custom_log(ERROR, "I don't know how I will start the VNF :(");
            return ERR_NCX_MISSING_PARM;
        }
    }
    //---------------------------------------------------------

    //setting control port, which has been read from startup-cfg.xml
    gchar* new_port = y_vnf_starter_get_a_port();
    //checking whether any available port is left
    if(new_port == NULL)
    {
        custom_log(ERROR, g_strdup_printf("There are no ports left!"));
        return ERR_NCX_RESOURCE_DENIED;
    }

    //create a VNF instance
    gchar* vnf1 = createVNF();
    custom_log(LOG, g_strdup_printf("VNF created (%s)", vnf1));

    //setting the command
    setVNFCommand(vnf1, vnf_command);

    setControlPort(vnf1, new_port);



    //iterating through options list
    while(options_val != NULL)
    {
        //finding name tag in option
        val_value_t* option_name =
                val_find_child(options_val,
                               y_vnf_starter_M_vnf_starter,
                               y_vnf_starter_N_name);

        custom_log(INFO, g_strdup_printf("Option_name:%s",
                                         VAL_STRING(option_name)));

        //finding value tag in option
        val_value_t* option_value =
                val_find_child(options_val,
                               y_vnf_starter_M_vnf_starter,
                               y_vnf_starter_N_value);

        custom_log(INFO, g_strdup_printf("Option_value:%s",
                                         VAL_STRING(option_value)));

        //Add all options to the vnf's datastructure
        addOptionsToVNF(vnf1,
                        g_strdup_printf("%s", VAL_STRING(option_name)),
                        g_strdup_printf("%s", VAL_STRING(option_value)));


        /****** +-+-+-+-+-+-########################-+-+-+-+-+-+-+-+-+ *******/
        /*      |           HERE, WE CAN HANDLE 'OPTIONS'            |       */
        /****** +-+-+-+-+-+-########################-+-+-+-+-+-+-+-+-+ *******/
        //in this part, the given option arguments can be parsed
            //setting control ip

            gchar* opt = g_strdup_printf("%s", VAL_STRING(option_name));

            if(g_strcmp0(opt, (gchar*)"ip") == 0)
            {
                //option ip found
                custom_log(INFO, "IP found");
                setControlIP(vnf1, g_strdup_printf("%s", VAL_STRING(option_value)));
            }

        /****** +-+-+-+-+-+-########################-+-+-+-+-+-+-+-+-+ *******/




        //jumping to the next option in the list
        options_val = val_find_next_child(msg->rpc_input,
                                        y_vnf_starter_M_vnf_starter,
                                        y_vnf_starter_N_options,
                                        options_val);
    }






    printVNFs();

    // -------------------- CREATING A CUSTOM RPC REPLY ------------------------
    //getting the rpc-reply's output, in particular the access_info list
    val_value_t *childval = NULL;
    childval = agt_make_list(
                    obj_find_child(initiateVNF_obj,
                                   y_vnf_starter_M_vnf_starter,
                                   "output"),
                    y_vnf_starter_N_access_info,
                    &res);

    if(childval != NULL)
    {
        custom_log(INFO,"List found and initialized");
    }

    //adding list elements
    //vnf_id
    val_value_t *a = NULL;
    a = agt_make_leaf(
        childval->obj,
        y_vnf_starter_N_vnf_id,
        (const xmlChar*)vnf1,
        &res);
    if(a!=NULL)
    {
        val_add_child(a,childval);
    }
    else
    {
        return res;
    }


    //control_ip
    a = agt_make_leaf(
        childval->obj,
        y_vnf_starter_N_control_ip,
        (const xmlChar*)getControlIP(vnf1),
        &res);
    if(a!=NULL)
    {
        val_add_child(a,childval);
    }
    else
    {
        return res;
    }


    //control_port
    a = agt_make_leaf(
        childval->obj,
        y_vnf_starter_N_control_port,
        (const xmlChar*)getControlPort(vnf1),
        &res);
    if(a!=NULL)
    {
        val_add_child(a,childval);
    }
    else
    {
        return res;
    }


    //TODO:  RPC-REPLY's output leaf 'other' should be implemented here

    //-----------------------------------------------------------------



    //send rpc-reply
    dlq_enque((void*)childval,&(msg->rpc_dataQ));

    // ----------------END OF CREATING A CUSTOM RPC REPLY ----------------------

    /* --------------- END LEVI ------------------- */
    return res;

} /* y_vnf_starter_initiateVNF_invoke */


/********************************************************************
* FUNCTION y_vnf_starter_connectVNF_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_vnf_starter_connectVNF_validate (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode)
{
    status_t res = NO_ERR;
    val_value_t *errorval = NULL;

    val_value_t *vnf_id_val;
    const xmlChar *vnf_id;
    val_value_t *vnf_port_val;
    const xmlChar *vnf_port;
    val_value_t *switch_id_val;
    const xmlChar *switch_id;

    vnf_id_val = val_find_child(
        msg->rpc_input,
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_vnf_id);
    if (vnf_id_val != NULL && vnf_id_val->res == NO_ERR) {
        vnf_id = VAL_STRING(vnf_id_val);
    }

    vnf_port_val = val_find_child(
        msg->rpc_input,
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_vnf_port);
    if (vnf_port_val != NULL && vnf_port_val->res == NO_ERR) {
        vnf_port = VAL_STRING(vnf_port_val);
    }

    switch_id_val = val_find_child(
        msg->rpc_input,
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_switch_id);
    if (switch_id_val != NULL && switch_id_val->res == NO_ERR) {
        switch_id = VAL_STRING(switch_id_val);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_OPERATION,
            res,
            methnode,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* y_vnf_starter_connectVNF_validate */


/********************************************************************
* FUNCTION y_vnf_starter_connectVNF_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_vnf_starter_connectVNF_invoke (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode)
{
    status_t res = NO_ERR;

    val_value_t *vnf_id_val;
    const xmlChar *vnf_id;
    val_value_t *vnf_port_val;
    const xmlChar *vnf_port;
    val_value_t *switch_id_val;
    const xmlChar *switch_id;

    vnf_id_val = val_find_child(
        msg->rpc_input,
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_vnf_id);
    if (vnf_id_val != NULL && vnf_id_val->res == NO_ERR) {
        vnf_id = VAL_STRING(vnf_id_val);
    }

    vnf_port_val = val_find_child(
        msg->rpc_input,
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_vnf_port);
    if (vnf_port_val != NULL && vnf_port_val->res == NO_ERR) {
        vnf_port = VAL_STRING(vnf_port_val);
    }

    switch_id_val = val_find_child(
        msg->rpc_input,
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_switch_id);
    if (switch_id_val != NULL && switch_id_val->res == NO_ERR) {
        switch_id = VAL_STRING(switch_id_val);
    }

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if methnode is used */
    (void)methnode;

    /* invoke your device instrumentation code here */
    /************************* LEVI *****************************/
   //vnf_id is a leaf and it is already read above
   //now, we check it!
   //checking whether the given vnf exists
    if(getVNF(vnf_id) == NULL)
    {

        custom_log(ERROR, g_strdup_printf("VNF %s does not exist", vnf_id));
        return ERR_NCX_INVALID_VALUE;
    }

    //checking that switch id was not null,
    //validate function handles only that switch id was sent, but a NULL can
    //also be sent, therefore we check its value, so not switch_id_val, but
    //switch_id instead
    if(g_strcmp0(switch_id, "") == 0)
    {
        custom_log(ERROR, "The given switch id is a NULL string!");
        return ERR_NCX_INVALID_VALUE;
    }

    //similarly, we check vnf_port as well
    if(g_strcmp0(vnf_port, "") == 0)
    {
        custom_log(ERROR, "The given vnf port is a NULL string!");
        return ERR_NCX_INVALID_VALUE;
    }

    //now, everything is ok
    //(re)connect vnf
    connectVNF((gchar*)vnf_id,(gchar*)vnf_port,(gchar*)switch_id);
    printVNFs();

    /* --------------- END LEVI ------------------- */
    
    return res;

} /* y_vnf_starter_connectVNF_invoke */


/********************************************************************
* FUNCTION y_vnf_starter_disconnectVNF_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_vnf_starter_disconnectVNF_validate (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode)
{
    status_t res = NO_ERR;
    val_value_t *errorval = NULL;

    val_value_t *vnf_id_val;
    const xmlChar *vnf_id;
    val_value_t *vnf_port_val;
    const xmlChar *vnf_port;

    vnf_id_val = val_find_child(
        msg->rpc_input,
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_vnf_id);
    if (vnf_id_val != NULL && vnf_id_val->res == NO_ERR) {
        vnf_id = VAL_STRING(vnf_id_val);
    }

    vnf_port_val = val_find_child(
        msg->rpc_input,
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_vnf_port);
    if (vnf_port_val != NULL && vnf_port_val->res == NO_ERR) {
        vnf_port = VAL_STRING(vnf_port_val);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_OPERATION,
            res,
            methnode,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* y_vnf_starter_disconnectVNF_validate */


/********************************************************************
* FUNCTION y_vnf_starter_disconnectVNF_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_vnf_starter_disconnectVNF_invoke (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode)
{
    status_t res = NO_ERR;

    val_value_t *vnf_id_val;
    const xmlChar *vnf_id;
    val_value_t *vnf_port_val;
    const xmlChar *vnf_port;

    vnf_id_val = val_find_child(
        msg->rpc_input,
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_vnf_id);
    if (vnf_id_val != NULL && vnf_id_val->res == NO_ERR) {
        vnf_id = VAL_STRING(vnf_id_val);
    }

    vnf_port_val = val_find_child(
        msg->rpc_input,
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_vnf_port);
    if (vnf_port_val != NULL && vnf_port_val->res == NO_ERR) {
        vnf_port = VAL_STRING(vnf_port_val);
    }

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if methnode is used */
    (void)methnode;

    /* invoke your device instrumentation code here */
    /************************* LEVI *****************************/
    //vnf_id is a leaf and it is already read above
    //now, we check it!
    //checking whether the given vnf exists
    if(getVNF(vnf_id) == NULL)
    {

        custom_log(ERROR, "No data to display");
        return ERR_NCX_INVALID_VALUE;
    }
    //checking whether vnf_port is not a NULL string
    if(g_strcmp0(vnf_port, "") == 0)
    {
        custom_log(ERROR, "The given vnf port is a NULL string!");
        return ERR_NCX_INVALID_VALUE;
    }

    //everything is ok
    //checking whether disconnect was successful
    if(disconnectVNF(vnf_id, vnf_port))
    {
        custom_log(INFO, g_strdup_printf("%s's port %s has been disconnected",
                                         vnf_id, vnf_port));

        //TODO:  RPC-REPLY's output leaf 'other' should be implemented here

        //-----------------------------------------------------------------
    }
    else
    {
        custom_log(ERROR, g_strdup_printf("%s's port %s could not "
                                          "be disconnected",
                                          vnf_id, vnf_port));

    }
    /* --------------- END LEVI ------------------- */
    return res;

} /* y_vnf_starter_disconnectVNF_invoke */


/********************************************************************
* FUNCTION y_vnf_starter_startVNF_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_vnf_starter_startVNF_validate (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode)
{
    status_t res = NO_ERR;
    val_value_t *errorval = NULL;

    val_value_t *vnf_id_val;
    const xmlChar *vnf_id;

    vnf_id_val = val_find_child(
        msg->rpc_input,
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_vnf_id);
    if (vnf_id_val != NULL && vnf_id_val->res == NO_ERR) {
        vnf_id = VAL_STRING(vnf_id_val);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_OPERATION,
            res,
            methnode,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* y_vnf_starter_startVNF_validate */


/********************************************************************
* FUNCTION y_vnf_starter_startVNF_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_vnf_starter_startVNF_invoke (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode)
{
    status_t res = NO_ERR;

    val_value_t *vnf_id_val;
    const xmlChar *vnf_id;

    vnf_id_val = val_find_child(
        msg->rpc_input,
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_vnf_id);
    if (vnf_id_val != NULL && vnf_id_val->res == NO_ERR) {
        vnf_id = VAL_STRING(vnf_id_val);
    }

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if methnode is used */
    (void)methnode;

    /* invoke your device instrumentation code here */
    /************************* LEVI *****************************/
    //vnf_id is a leaf and it is already read above
    //now, we check it!
    //checking whether the given vnf exists
    if(getVNF(vnf_id) == NULL)
    {
        custom_log(ERROR, g_strdup_printf("There is no such vnf (%s)",vnf_id));
        return ERR_NCX_INVALID_VALUE;
    }

    startVNF(vnf_id);

    //TODO:  RPC-REPLY's output leaf 'other' should be implemented here

    //-----------------------------------------------------------------


    /* --------------- END LEVI ------------------- */
    return res;

} /* y_vnf_starter_startVNF_invoke */


/********************************************************************
* FUNCTION y_vnf_starter_stopVNF_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_vnf_starter_stopVNF_validate (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode)
{
    status_t res = NO_ERR;
    val_value_t *errorval = NULL;

    val_value_t *vnf_id_val;
    const xmlChar *vnf_id;

    vnf_id_val = val_find_child(
        msg->rpc_input,
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_vnf_id);
    if (vnf_id_val != NULL && vnf_id_val->res == NO_ERR) {
        vnf_id = VAL_STRING(vnf_id_val);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_OPERATION,
            res,
            methnode,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* y_vnf_starter_stopVNF_validate */


/********************************************************************
* FUNCTION y_vnf_starter_stopVNF_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_vnf_starter_stopVNF_invoke (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode)
{
    status_t res = NO_ERR;

    val_value_t *vnf_id_val;
    const xmlChar *vnf_id;

    vnf_id_val = val_find_child(
        msg->rpc_input,
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_vnf_id);
    if (vnf_id_val != NULL && vnf_id_val->res == NO_ERR) {
        vnf_id = VAL_STRING(vnf_id_val);
    }

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if methnode is used */
    (void)methnode;

    /* invoke your device instrumentation code here */
    // ---------------------- LEVI ------------------------
    //checking whether the given vnf exists
    if(getVNF(vnf_id) == NULL)
    {
        custom_log(ERROR, g_strdup_printf("There is no such vnf (%s)",vnf_id));
        return ERR_NCX_INVALID_VALUE;
    }

    //before stopping vnf, the control port the vnf has used needs to be set
    //back to available
    gchar* used_port = getControlPort(vnf_id);

    available_control_ports = g_slist_append(available_control_ports,
                                             g_strdup(used_port));
    //we do not need this variable any more
    g_free(used_port);

    //stopping vnf
    stopVNF(vnf_id);


    //TODO:  RPC-REPLY's output leaf 'other' should be implemented here

    //-----------------------------------------------------------------


    // -------------------- END LEVI ----------------------
    return res;

} /* y_vnf_starter_stopVNF_invoke */


/********************************************************************
* FUNCTION y_vnf_starter_getVNFInfo_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_vnf_starter_getVNFInfo_validate (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode)
{
    status_t res = NO_ERR;
    val_value_t *errorval = NULL;

    val_value_t *vnf_id_val;
    const xmlChar *vnf_id;

    vnf_id_val = val_find_child(
        msg->rpc_input,
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_vnf_id);
    if (vnf_id_val != NULL && vnf_id_val->res == NO_ERR) {
        vnf_id = VAL_STRING(vnf_id_val);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_OPERATION,
            res,
            methnode,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* y_vnf_starter_getVNFInfo_validate */


/********************************************************************
* FUNCTION y_vnf_starter_getVNFInfo_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_vnf_starter_getVNFInfo_invoke (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode)
{
    status_t res = NO_ERR;

    val_value_t *vnf_id_val;
    const xmlChar *vnf_id;

    vnf_id_val = val_find_child(
        msg->rpc_input,
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_vnf_id);
    if (vnf_id_val != NULL && vnf_id_val->res == NO_ERR) {
        vnf_id = VAL_STRING(vnf_id_val);
    }

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if methnode is used */
    (void)methnode;

    /* invoke your device instrumentation code here */
    /************************* LEVI *****************************/
    //vnf_id is a leaf and it is already read above
    //check whether it is set or not
    if(vnf_id_val != NULL)
    {
        //vnf_id is set,
        //check whether the given vnf exists
        if(getVNF(vnf_id) == NULL)
        {
            custom_log(ERROR, g_strdup_printf("There is no such vnf (%s)",vnf_id));
            return ERR_NCX_INVALID_VALUE;
        }

        //vnf_id was correctly set


        // ----------------- CREATING THE CUSTOM RPC-REPLY -----------------
        //it is done by a helper function called
        //y_vnf_starter_get_initiated_vnf_data

        //send rpc-reply
        dlq_enque((void*)y_vnf_starter_get_initiated_vnf_data(res, vnf_id),&(msg->rpc_dataQ));


        // ----------------END OF CREATING A CUSTOM RPC REPLY ------------------
    }
    else
    {
        //TODO: get all initiated vnfs' data
        //getting the ids of all vnfs
        GSList* vnf_ids = getVNFIds();

        //let's iterate through them and create and send the rpc-reply
        GSList* iterator = NULL;
        for(iterator = vnf_ids; iterator; iterator = iterator->next)
        {
            //adding list elements to rpc-reply
            dlq_enque((void*)y_vnf_starter_get_initiated_vnf_data(
                                res,
                                (gchar*)iterator->data),
                      &(msg->rpc_dataQ));
        }

    }

    //TODO:  RPC-REPLY's output leaf 'other' should be implemented here

    //-----------------------------------------------------------------

    /* --------------- END LEVI ------------------- */
    return res;

} /* y_vnf_starter_getVNFInfo_invoke */



/************************* LEVI *****************************/
/*
 * This helper function gets a vnf's data and returns it as a xml_list for
 * RPC-REPLY of getVNFInfo
 * gchar* vnf_id - the id of the vnf
 * returns val_value_t* - the list of a vnf's data
 */
val_value_t* y_vnf_starter_get_initiated_vnf_data(status_t res, gchar* vnf_id)
{
    //getting the rpc-reply's output, in particular the initiated_vnfs list
    obj_template_t *rpc_output_obj = obj_find_child(getVNFInfo_obj,
                                             y_vnf_starter_M_vnf_starter,
                                             "output");
    val_value_t *initiated_vnfs = NULL;
    initiated_vnfs = agt_make_list(
                                    rpc_output_obj,
                                    y_vnf_starter_N_initiated_vnfs,
                                    &res);
    if(initiated_vnfs != NULL)
    {
        custom_log(INFO,"List found and initialized");
    }

        //adding list elements
        //vnf_id
        val_value_t *a = NULL;
        a = agt_make_leaf(
            initiated_vnfs->obj,
            y_vnf_starter_N_vnf_id,
            (const xmlChar*)vnf_id,
            &res);
        if(a!=NULL)
        {
            val_add_child(a,initiated_vnfs);
        }
        else
        {
            return NULL;
        }


        //pid
        a = agt_make_leaf(
            initiated_vnfs->obj,
            y_vnf_starter_N_pid,
            (const xmlChar*)g_strdup_printf("%d", getPid(vnf_id)),
            &res);
        if(a!=NULL)
        {
            val_add_child(a,initiated_vnfs);
        }
        else
        {
            return NULL;
        }

        //control_ip
        a = agt_make_leaf(
            initiated_vnfs->obj,
            y_vnf_starter_N_control_ip,
            (const xmlChar*)getControlIP(vnf_id),
            &res);
        if(a!=NULL)
        {
            val_add_child(a,initiated_vnfs);
        }
        else
        {
            return NULL;
        }

        //control_port
        a = agt_make_leaf(
            initiated_vnfs->obj,
            y_vnf_starter_N_control_port,
            (const xmlChar*)getControlPort(vnf_id),
            &res);
        if(a!=NULL)
        {
            val_add_child(a,initiated_vnfs);
        }
        else
        {
            return NULL;
        }

        //command
        a = agt_make_leaf(
            initiated_vnfs->obj,
            y_vnf_starter_N_command,
            (const xmlChar*)getVNFCommand(vnf_id),
            &res);
        if(a!=NULL)
        {
            val_add_child(a,initiated_vnfs);
        }
        else
        {
            return NULL;
        }


        //status
        a = agt_make_leaf(
            initiated_vnfs->obj,
            y_vnf_starter_N_status,
            (const xmlChar*)"UP_AND_RUNNING",
            &res);
        if(a!=NULL)
        {
            val_add_child(a,initiated_vnfs);
        }
        else
        {
            return NULL;
        }

        //TODO: here could be the other leaf for a vnf handled similarly to
        //handling above such as //status



        //get the links
        GHashTable* links_hashtable = getLinksHashtable(vnf_id);


        //get the keys of the hashtable

        GList* keys = g_hash_table_get_keys(links_hashtable);
        GList* iterator = NULL;
        for(iterator = keys; iterator; iterator = iterator->next)
        {
            val_value_t *link = NULL;
            link = agt_make_list(
                                initiated_vnfs->obj,
                                y_vnf_starter_N_link,
                                &res);
            if(link != NULL)
            {
                custom_log(INFO,"List of link found and initialized");

            }

            custom_log(LOG, "Iterating through links");
            //vnf_port which comes from the keys
            val_value_t *l = NULL;
            l = agt_make_leaf(
                link->obj,
                y_vnf_starter_N_vnf_port,
                (const xmlChar*)iterator->data,
                &res);
            if(l!=NULL)
            {
                custom_log(LOG, g_strdup_printf("vnf_port=%s", (gchar*)iterator->data));
                val_add_child(l,link);
            }
            else
            {
                custom_log(ERROR, "VNF_PORT was not found");
                return NULL;
            }

            //now get the corresponding link data
            vnf_link* a_link = g_hash_table_lookup(links_hashtable, (gchar*)iterator->data);

            //vnf_dev
            l = agt_make_leaf(
                link->obj,
                y_vnf_starter_N_vnf_dev,
                (const xmlChar*)a_link->vnf_dev,
                &res);
            if(l!=NULL)
            {
                custom_log(LOG, g_strdup_printf("vnf_dev=%s", a_link->vnf_dev));
                val_add_child(l,link);
            }
            else
            {
                custom_log(ERROR, "VNF_DEF was not found");
                return NULL;
            }

            //vnf_dev_mac
            l = agt_make_leaf(
                link->obj,
                y_vnf_starter_N_vnf_dev_mac,
                (const xmlChar*)a_link->vnf_dev_mac,
                &res);
            if(l!=NULL)
            {
                custom_log(LOG, g_strdup_printf("vnf_dev_mac=%s", a_link->vnf_dev_mac));
                val_add_child(l,link);
            }
            else
            {
                custom_log(ERROR, "VNF_DEF_MAC was not found");
                return NULL;
            }


            //sw_dev
            l = agt_make_leaf(
                link->obj,
                y_vnf_starter_N_sw_dev,
                (const xmlChar*)a_link->sw_dev,
                &res);
            if(l!=NULL)
            {
                custom_log(LOG, g_strdup_printf("sw_dev=%s", a_link->sw_dev));
                val_add_child(l,link);
            }
            else
            {
                custom_log(ERROR, "SW_DEV was not found");
                return NULL;
            }

            //sw_id
            l = agt_make_leaf(
                link->obj,
                y_vnf_starter_N_sw_id,
                (const xmlChar*)a_link->sw_id,
                &res);
            if(l!=NULL)
            {
                custom_log(LOG, g_strdup_printf("sw_id=%s", a_link->sw_id));
                val_add_child(l,link);
            }
            else
            {
                custom_log(ERROR, "SW_ID was not found");
                return NULL;
            }

            //sw_port
            l = agt_make_leaf(
                link->obj,
                y_vnf_starter_N_sw_port,
                (const xmlChar*)a_link->sw_port,
                &res);
            if(l!=NULL)
            {
                custom_log(LOG, g_strdup_printf("sw_port=%s", a_link->sw_port));
                val_add_child(l,link);
            }
            else
            {
                custom_log(ERROR, "SW_PORT was not found");
                return NULL;
            }

            //connected
            gchar* connected = NULL;
            if(a_link->connected)
            {
                connected = g_strdup_printf("CONNECTED");
            }
            else
            {
                connected = g_strdup_printf("DISCONNECTED");
            }

            l = agt_make_leaf(
                link->obj,
                y_vnf_starter_N_connected,
                (const xmlChar*)connected,
                &res);
            if(l!=NULL)
            {
                val_add_child(l,link);
            }
            else
            {
                custom_log(ERROR, "CONNECTED was not found");
                return NULL;
            }

            //adding link list to initiated_vnfs list
            val_add_child(link, initiated_vnfs);
        }



    return initiated_vnfs;

}
/* --------------- END LEVI ------------------- */



/********************************************************************
* FUNCTION y_vnf_starter_init
* 
* initialize the vnf_starter server instrumentation library
* 
* INPUTS:
*    modname == requested module name
*    revision == requested version (NULL for any)
* 
* RETURNS:
*     error status
********************************************************************/
status_t y_vnf_starter_init (
    const xmlChar *modname,
    const xmlChar *revision)
{
    status_t res = NO_ERR;
    agt_profile_t *agt_profile = agt_get_profile();

    y_vnf_starter_init_static_vars();

    /* change if custom handling done */
    if (xml_strcmp(modname, y_vnf_starter_M_vnf_starter)) {
        return ERR_NCX_UNKNOWN_MODULE;
    }

    if (revision && xml_strcmp(revision, y_vnf_starter_R_vnf_starter)) {
        return ERR_NCX_WRONG_VERSION;
    }
    res = ncxmod_load_module(
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_R_vnf_starter,
        &agt_profile->agt_savedevQ,
        &vnf_starter_mod);
    if (res != NO_ERR) {
        return res;
    }

    vnf_starter_obj = ncx_find_object(
        vnf_starter_mod,
        y_vnf_starter_N_vnf_starter);
    if (vnf_starter_mod == NULL) {
        return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
    }
    initiateVNF_obj = ncx_find_object(
        vnf_starter_mod,
        y_vnf_starter_N_initiateVNF);
    if (vnf_starter_mod == NULL) {
        return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
    }
    connectVNF_obj = ncx_find_object(
        vnf_starter_mod,
        y_vnf_starter_N_connectVNF);
    if (vnf_starter_mod == NULL) {
        return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
    }
    disconnectVNF_obj = ncx_find_object(
        vnf_starter_mod,
        y_vnf_starter_N_disconnectVNF);
    if (vnf_starter_mod == NULL) {
        return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
    }
    startVNF_obj = ncx_find_object(
        vnf_starter_mod,
        y_vnf_starter_N_startVNF);
    if (vnf_starter_mod == NULL) {
        return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
    }
    stopVNF_obj = ncx_find_object(
        vnf_starter_mod,
        y_vnf_starter_N_stopVNF);
    if (vnf_starter_mod == NULL) {
        return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
    }
    getVNFInfo_obj = ncx_find_object(
        vnf_starter_mod,
        y_vnf_starter_N_getVNFInfo);
    if (vnf_starter_mod == NULL) {
        return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
    }
    res = agt_rpc_register_method(
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_initiateVNF,
        AGT_RPC_PH_VALIDATE,
        y_vnf_starter_initiateVNF_validate);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_initiateVNF,
        AGT_RPC_PH_INVOKE,
        y_vnf_starter_initiateVNF_invoke);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_connectVNF,
        AGT_RPC_PH_VALIDATE,
        y_vnf_starter_connectVNF_validate);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_connectVNF,
        AGT_RPC_PH_INVOKE,
        y_vnf_starter_connectVNF_invoke);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_disconnectVNF,
        AGT_RPC_PH_VALIDATE,
        y_vnf_starter_disconnectVNF_validate);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_disconnectVNF,
        AGT_RPC_PH_INVOKE,
        y_vnf_starter_disconnectVNF_invoke);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_startVNF,
        AGT_RPC_PH_VALIDATE,
        y_vnf_starter_startVNF_validate);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_startVNF,
        AGT_RPC_PH_INVOKE,
        y_vnf_starter_startVNF_invoke);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_stopVNF,
        AGT_RPC_PH_VALIDATE,
        y_vnf_starter_stopVNF_validate);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_stopVNF,
        AGT_RPC_PH_INVOKE,
        y_vnf_starter_stopVNF_invoke);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_getVNFInfo,
        AGT_RPC_PH_VALIDATE,
        y_vnf_starter_getVNFInfo_validate);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_getVNFInfo,
        AGT_RPC_PH_INVOKE,
        y_vnf_starter_getVNFInfo_invoke);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_vnf_starter_M_vnf_starter,
        (const xmlChar *)"/vnf_starter",
        y_vnf_starter_R_vnf_starter,
        vnf_starter_vnf_starter_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_vnf_starter_M_vnf_starter,
        (const xmlChar *)"/vnf_starter/agent_name",
        y_vnf_starter_R_vnf_starter,
        vnf_starter_vnf_starter_agent_name_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_vnf_starter_M_vnf_starter,
        (const xmlChar *)"/vnf_starter/switch_id",
        y_vnf_starter_R_vnf_starter,
        vnf_starter_vnf_starter_switch_id_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_vnf_starter_M_vnf_starter,
        (const xmlChar *)"/vnf_starter/click_port_min",
        y_vnf_starter_R_vnf_starter,
        vnf_starter_vnf_starter_click_port_min_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_vnf_starter_M_vnf_starter,
        (const xmlChar *)"/vnf_starter/click_port_max",
        y_vnf_starter_R_vnf_starter,
        vnf_starter_vnf_starter_click_port_max_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_vnf_starter_M_vnf_starter,
        (const xmlChar *)"/vnf_starter/available_vnfs",
        y_vnf_starter_R_vnf_starter,
        vnf_starter_vnf_starter_available_vnfs_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_vnf_starter_M_vnf_starter,
        (const xmlChar *)"/vnf_starter/available_vnfs/vnf_type",
        y_vnf_starter_R_vnf_starter,
        vnf_starter_vnf_starter_available_vnfs_vnf_type_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_vnf_starter_M_vnf_starter,
        (const xmlChar *)"/vnf_starter/available_vnfs/vnf_description",
        y_vnf_starter_R_vnf_starter,
        vnf_starter_vnf_starter_available_vnfs_vnf_description_edit);
    if (res != NO_ERR) {
        return res;
    }

    /* put your module initialization code here */
    
    return res;
} /* y_vnf_starter_init */

/********************************************************************
* FUNCTION y_vnf_starter_init2
* 
* SIL init phase 2: non-config data structures
* Called after running config is loaded
* 
* RETURNS:
*     error status
********************************************************************/
status_t y_vnf_starter_init2 (void)
{
    status_t res = NO_ERR;

    vnf_starter_val = agt_init_cache(
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_vnf_starter,
        &res);
    if (res != NO_ERR) {
        return res;
    }

    /* put your init2 code here */
    /* -------------- LEVI ---------------- */
    gchar *v;
    //getting config. vars from startup_xml
    v = y_vnf_starter_get_startup_parameter(y_vnf_starter_N_agent_name);
    if (v) {
      startup_agent_name = v;
    }

    v = y_vnf_starter_get_startup_parameter(y_vnf_starter_N_switch_id);
    if (v) {
      startup_switch_id = v;
    }

    v = y_vnf_starter_get_startup_parameter(y_vnf_starter_N_click_port_min);
    if (v) {
      startup_click_port_min = v;
    }

    v = y_vnf_starter_get_startup_parameter(y_vnf_starter_N_click_port_max);
    if (v) {
      startup_click_port_max = v;
    }


    //getting available_vnfs from startup_xml
    val_value_t *available_vnfs =
            val_find_child(vnf_starter_val,
                           y_vnf_starter_M_vnf_starter,
                           y_vnf_starter_N_available_vnfs);

    //iterating through options list
    while(available_vnfs != NULL)
    {
        //finding vnf_type tag in option
        val_value_t* vnf_type =
                val_find_child(available_vnfs,
                               y_vnf_starter_M_vnf_starter,
                               y_vnf_starter_N_vnf_type);

        //variable for vnf_type element
        gchar* vnf_type_text = g_strdup("");

        //checking whether vnf_type exists
        if(vnf_type == NULL)
        {
            //it was not set
            vnf_type_text = g_strdup_printf("N/A");
        }
        else
        {
            //it was set, so read it
            vnf_type_text = g_strdup_printf("%s", VAL_STRING(vnf_type));
        }

        custom_log(INFO, g_strdup_printf("VNF type:%s", vnf_type_text));

        //finding vnf_description tag in option
        val_value_t* vnf_description =
                val_find_child(available_vnfs,
                               y_vnf_starter_M_vnf_starter,
                               y_vnf_starter_N_vnf_description);


        //variable for vnf_description element
       gchar* vnf_desc_text = g_strdup("");
       //checking whether vnf_description exists
       if(vnf_description == NULL)
       {
           //it was not set
           vnf_desc_text = g_strdup_printf("N/A");
       }
       else
       {
           //it was set, so read it
          vnf_desc_text = g_strdup_printf("%s", VAL_STRING(vnf_description));
       }
        custom_log(INFO, g_strdup_printf("VNF description:%s",
                                         vnf_desc_text));

        //putting these data into our hashtable
        g_hash_table_insert(startup_available_vnfs,
                            vnf_type_text,
                            vnf_desc_text);

        //jumping to the next option in the list
        available_vnfs = val_find_next_child(available_vnfs,
                                        y_vnf_starter_M_vnf_starter,
                                        y_vnf_starter_N_available_vnfs,
                                        available_vnfs);
    }

    //print green line
    log_info_bar();
    custom_log(INFO, "Startup configuration parsed!");
    custom_log(INFO,g_strdup_printf("\tagent name: %s",
                                    startup_agent_name));
    custom_log(INFO,g_strdup_printf("\tswitch id: %s",
                                        startup_switch_id));
    custom_log(INFO,g_strdup_printf("\tclick port min: %s",
                                    startup_click_port_min));
    custom_log(INFO,g_strdup_printf("\tclick port max: %s",
                                        startup_click_port_max));
    custom_log(INFO, "\tavailable vnfs:");
    g_hash_table_foreach(startup_available_vnfs,
                         (GHFunc)print_hashtable_values_as_gchar,
                         NULL);
    //print green line
    log_info_bar();


    //creating a list of the available control ports
    int cp_min = atoi(startup_click_port_min);
    int cp_max = atoi(startup_click_port_max);
    for(cp_min; cp_min <= cp_max; cp_min++)
    {
        available_control_ports = g_slist_append(available_control_ports,
                                                g_strdup_printf("%d",cp_min));
    }
    //print available control ports
    custom_log(INFO, "Available control ports:");
    print_list_data(available_control_ports);


    /* ------------ END LEVI -------------- */
    return res;
} /* y_vnf_starter_init2 */

/********************************************************************
* FUNCTION y_vnf_starter_cleanup
*    cleanup the server instrumentation library
* 
********************************************************************/
void y_vnf_starter_cleanup (void)
{
    
    agt_rpc_unregister_method(
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_initiateVNF);
    
    agt_rpc_unregister_method(
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_connectVNF);
    
    agt_rpc_unregister_method(
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_disconnectVNF);
    
    agt_rpc_unregister_method(
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_startVNF);
    
    agt_rpc_unregister_method(
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_stopVNF);
    
    agt_rpc_unregister_method(
        y_vnf_starter_M_vnf_starter,
        y_vnf_starter_N_getVNFInfo);
    agt_cb_unregister_callbacks(
        y_vnf_starter_M_vnf_starter,
        (const xmlChar *)"/vnf_starter");

    agt_cb_unregister_callbacks(
        y_vnf_starter_M_vnf_starter,
        (const xmlChar *)"/vnf_starter/agent_name");

    agt_cb_unregister_callbacks(
        y_vnf_starter_M_vnf_starter,
        (const xmlChar *)"/vnf_starter/switch_id");

    agt_cb_unregister_callbacks(
        y_vnf_starter_M_vnf_starter,
        (const xmlChar *)"/vnf_starter/click_port_min");

    agt_cb_unregister_callbacks(
        y_vnf_starter_M_vnf_starter,
        (const xmlChar *)"/vnf_starter/click_port_max");

    agt_cb_unregister_callbacks(
        y_vnf_starter_M_vnf_starter,
        (const xmlChar *)"/vnf_starter/available_vnfs");

    agt_cb_unregister_callbacks(
        y_vnf_starter_M_vnf_starter,
        (const xmlChar *)"/vnf_starter/available_vnfs/vnf_type");

    agt_cb_unregister_callbacks(
        y_vnf_starter_M_vnf_starter,
        (const xmlChar *)"/vnf_starter/available_vnfs/vnf_description");

    /* put your cleanup code here */
    
} /* y_vnf_starter_cleanup */

/* ******************* LEVI ******************* */
/*
 * This process returns startup parameters set in startup.xml
 * const xmlChar* element - needed element, e.g., y_vnf_starter_N_agent_name
 * return gchar* - value defined in the found element, if not found it returns
 * NULL
 */
gchar* y_vnf_starter_get_startup_parameter(const xmlChar* element)
{
    val_value_t *tmp = NULL;
    tmp = val_find_child(vnf_starter_val,
                         y_vnf_starter_M_vnf_starter,
                         element);
    if(tmp != NULL)
    {
        return (gchar*)tmp->v.fname;
    }
    return NULL;
}


/*
 * This process is devoted to get a port from the available ports.
 * Basically, it reads the last element in the available_ports list, and then
 * removes it from the list
 * return gchar* - A port
 */
gchar* y_vnf_starter_get_a_port(void)
{
    //getting the last element
    GSList* element = g_slist_last(available_control_ports);
    gchar* selected_port_1 = NULL;
    if(element == NULL)
    {
        return NULL;
    }

    selected_port_1 = element->data;

    //printing last element
//  custom_log(LOG, g_strdup_printf("Last element is: %s",
//                                  selected_port_1));

    //remove the last element
    available_control_ports = g_slist_remove(available_control_ports,
                                             selected_port_1);

    return g_strdup(selected_port_1);
}

/* -------------- END LEVI ----------------- */


/* END vnf_starter.c */
