
#ifndef _H_vnf_starter
#define _H_vnf_starter
/* 
 * Copyright (c) 2008-2012, Andy Bierman, All Rights Reserved.
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *

*** Generated by yangdump 2.2-5

    Combined SIL header
    module vnf_starter
    revision 2014-05-13
    namespace http://csikor.tmit.bme.hu/netconf/unify/vnf_starter
    organization BME-TMIT

*** Features are implemented by Levente Csikor <csikor@tmit.bme.hu>
    All additions are denoted by
    ---------------- LEVI ------------------
    ...
    ...
    ... additional implementation
    ...
    ...
    ------------ END LEVI ------------------
 */

#include <xmlstring.h>

#include "dlq.h"
#include "ncxtypes.h"
#include "op.h"
#include "status.h"
#include "val.h"

/* added by Levente Csikor */
#include "vnfs.h"
/* ---- */

#ifdef __cplusplus
extern "C" {
#endif

#define y_vnf_starter_M_vnf_starter (const xmlChar *)"vnf_starter"
#define y_vnf_starter_R_vnf_starter (const xmlChar *)"2014-05-13"

#define y_vnf_starter_N_access_info (const xmlChar *)"access_info"
#define y_vnf_starter_N_agent_name (const xmlChar *)"agent_name"
#define y_vnf_starter_N_available_vnfs (const xmlChar *)"available_vnfs"
#define y_vnf_starter_N_click_port_max (const xmlChar *)"click_port_max"
#define y_vnf_starter_N_click_port_min (const xmlChar *)"click_port_min"
#define y_vnf_starter_N_command (const xmlChar *)"command"
#define y_vnf_starter_N_connectVNF (const xmlChar *)"connectVNF"
#define y_vnf_starter_N_connected (const xmlChar *)"connected"
#define y_vnf_starter_N_control_ip (const xmlChar *)"control_ip"
#define y_vnf_starter_N_control_port (const xmlChar *)"control_port"
#define y_vnf_starter_N_disconnectVNF (const xmlChar *)"disconnectVNF"
#define y_vnf_starter_N_getVNFInfo (const xmlChar *)"getVNFInfo"
#define y_vnf_starter_N_initiateVNF (const xmlChar *)"initiateVNF"
#define y_vnf_starter_N_initiated_vnfs (const xmlChar *)"initiated_vnfs"
#define y_vnf_starter_N_link (const xmlChar *)"link"
#define y_vnf_starter_N_name (const xmlChar *)"name"
#define y_vnf_starter_N_options (const xmlChar *)"options"
#define y_vnf_starter_N_other (const xmlChar *)"other"
#define y_vnf_starter_N_pid (const xmlChar *)"pid"
#define y_vnf_starter_N_port (const xmlChar *)"port"
#define y_vnf_starter_N_startVNF (const xmlChar *)"startVNF"
#define y_vnf_starter_N_status (const xmlChar *)"status"
#define y_vnf_starter_N_stopVNF (const xmlChar *)"stopVNF"
#define y_vnf_starter_N_sw_dev (const xmlChar *)"sw_dev"
#define y_vnf_starter_N_sw_id (const xmlChar *)"sw_id"
#define y_vnf_starter_N_sw_port (const xmlChar *)"sw_port"
#define y_vnf_starter_N_switch_id (const xmlChar *)"switch_id"
#define y_vnf_starter_N_value (const xmlChar *)"value"
#define y_vnf_starter_N_vnf_description (const xmlChar *)"vnf_description"
#define y_vnf_starter_N_vnf_dev (const xmlChar *)"vnf_dev"
#define y_vnf_starter_N_vnf_dev_mac (const xmlChar *)"vnf_dev_mac"
#define y_vnf_starter_N_vnf_id (const xmlChar *)"vnf_id"
#define y_vnf_starter_N_vnf_port (const xmlChar *)"vnf_port"
#define y_vnf_starter_N_vnf_starter (const xmlChar *)"vnf_starter"
#define y_vnf_starter_N_vnf_type (const xmlChar *)"vnf_type"

/* leaf-list /vnf_starter/switch_id */
typedef struct y_vnf_starter_T_vnf_starter_switch_id_ {
    dlq_hdr_t qhdr;
    xmlChar *switch_id;
} y_vnf_starter_T_vnf_starter_switch_id;

/* list /vnf_starter/available_vnfs */
typedef struct y_vnf_starter_T_vnf_starter_available_vnfs_ {
    dlq_hdr_t qhdr;
    xmlChar *vnf_type;
    xmlChar *vnf_description;
} y_vnf_starter_T_vnf_starter_available_vnfs;

/* container /vnf_starter */
typedef struct y_vnf_starter_T_vnf_starter_ {
    xmlChar *agent_name;
    dlq_hdr_t switch_id;
    xmlChar *click_port_min;
    xmlChar *click_port_max;
    dlq_hdr_t available_vnfs;
} y_vnf_starter_T_vnf_starter;

/* list /initiateVNF/input/options */
typedef struct y_vnf_starter_T_initiateVNF_input_options_ {
    dlq_hdr_t qhdr;
    xmlChar *name;
    xmlChar *value;
} y_vnf_starter_T_initiateVNF_input_options;

/* container /initiateVNF/input */
typedef struct y_vnf_starter_T_initiateVNF_input_ {
    xmlChar *vnf_type;
    xmlChar *vnf_description;
    dlq_hdr_t options;
} y_vnf_starter_T_initiateVNF_input;

/* list /initiateVNF/output/access_info */
typedef struct y_vnf_starter_T_initiateVNF_output_access_info_ {
    dlq_hdr_t qhdr;
    xmlChar *vnf_id;
    xmlChar *control_ip;
    xmlChar *control_port;
} y_vnf_starter_T_initiateVNF_output_access_info;

/* container /initiateVNF/output */
typedef struct y_vnf_starter_T_initiateVNF_output_ {
    dlq_hdr_t access_info;
    xmlChar *other;
} y_vnf_starter_T_initiateVNF_output;

/* rpc /initiateVNF */
typedef struct y_vnf_starter_T_initiateVNF_ {
    y_vnf_starter_T_initiateVNF_input input;
    y_vnf_starter_T_initiateVNF_output output;
} y_vnf_starter_T_initiateVNF;

/* container /connectVNF/input */
typedef struct y_vnf_starter_T_connectVNF_input_ {
    xmlChar *vnf_id;
    xmlChar *vnf_port;
    xmlChar *switch_id;
} y_vnf_starter_T_connectVNF_input;

/* container /connectVNF/output */
typedef struct y_vnf_starter_T_connectVNF_output_ {
    xmlChar *port;
    xmlChar *other;
} y_vnf_starter_T_connectVNF_output;

/* rpc /connectVNF */
typedef struct y_vnf_starter_T_connectVNF_ {
    y_vnf_starter_T_connectVNF_input input;
    y_vnf_starter_T_connectVNF_output output;
} y_vnf_starter_T_connectVNF;

/* container /disconnectVNF/input */
typedef struct y_vnf_starter_T_disconnectVNF_input_ {
    xmlChar *vnf_id;
    xmlChar *vnf_port;
} y_vnf_starter_T_disconnectVNF_input;

/* container /disconnectVNF/output */
typedef struct y_vnf_starter_T_disconnectVNF_output_ {
    xmlChar *other;
} y_vnf_starter_T_disconnectVNF_output;

/* rpc /disconnectVNF */
typedef struct y_vnf_starter_T_disconnectVNF_ {
    y_vnf_starter_T_disconnectVNF_input input;
    y_vnf_starter_T_disconnectVNF_output output;
} y_vnf_starter_T_disconnectVNF;

/* container /startVNF/input */
typedef struct y_vnf_starter_T_startVNF_input_ {
    xmlChar *vnf_id;
} y_vnf_starter_T_startVNF_input;

/* container /startVNF/output */
typedef struct y_vnf_starter_T_startVNF_output_ {
    xmlChar *other;
} y_vnf_starter_T_startVNF_output;

/* rpc /startVNF */
typedef struct y_vnf_starter_T_startVNF_ {
    y_vnf_starter_T_startVNF_input input;
    y_vnf_starter_T_startVNF_output output;
} y_vnf_starter_T_startVNF;

/* container /stopVNF/input */
typedef struct y_vnf_starter_T_stopVNF_input_ {
    xmlChar *vnf_id;
} y_vnf_starter_T_stopVNF_input;

/* container /stopVNF/output */
typedef struct y_vnf_starter_T_stopVNF_output_ {
    xmlChar *other;
} y_vnf_starter_T_stopVNF_output;

/* rpc /stopVNF */
typedef struct y_vnf_starter_T_stopVNF_ {
    y_vnf_starter_T_stopVNF_input input;
    y_vnf_starter_T_stopVNF_output output;
} y_vnf_starter_T_stopVNF;

/* container /getVNFInfo/input */
typedef struct y_vnf_starter_T_getVNFInfo_input_ {
    xmlChar *vnf_id;
} y_vnf_starter_T_getVNFInfo_input;

/* list /getVNFInfo/output/initiated_vnfs/link */
typedef struct y_vnf_starter_T_getVNFInfo_output_initiated_vnfs_link_ {
    dlq_hdr_t qhdr;
    xmlChar *vnf_port;
    xmlChar *vnf_dev;
    xmlChar *vnf_dev_mac;
    xmlChar *sw_dev;
    xmlChar *sw_id;
    xmlChar *sw_port;
    xmlChar *connected;
} y_vnf_starter_T_getVNFInfo_output_initiated_vnfs_link;

/* list /getVNFInfo/output/initiated_vnfs */
typedef struct y_vnf_starter_T_getVNFInfo_output_initiated_vnfs_ {
    dlq_hdr_t qhdr;
    xmlChar *vnf_id;
    xmlChar *pid;
    dlq_hdr_t link;
    xmlChar *control_ip;
    xmlChar *control_port;
    xmlChar *command;
    xmlChar *status;
    xmlChar *other;
} y_vnf_starter_T_getVNFInfo_output_initiated_vnfs;

/* container /getVNFInfo/output */
typedef struct y_vnf_starter_T_getVNFInfo_output_ {
    dlq_hdr_t initiated_vnfs;
} y_vnf_starter_T_getVNFInfo_output;

/* rpc /getVNFInfo */
typedef struct y_vnf_starter_T_getVNFInfo_ {
    y_vnf_starter_T_getVNFInfo_input input;
    y_vnf_starter_T_getVNFInfo_output output;
} y_vnf_starter_T_getVNFInfo;
/********************************************************************
* FUNCTION y_vnf_starter_init
* 
* initialize the vnf_starter server instrumentation library
* 
* INPUTS:
*    modname == requested module name
*    revision == requested version (NULL for any)
* 
* RETURNS:
*     error status
********************************************************************/
extern status_t y_vnf_starter_init (
    const xmlChar *modname,
    const xmlChar *revision);

/********************************************************************
* FUNCTION y_vnf_starter_init2
* 
* SIL init phase 2: non-config data structures
* Called after running config is loaded
* 
* RETURNS:
*     error status
********************************************************************/
extern status_t y_vnf_starter_init2 (void);

/********************************************************************
* FUNCTION y_vnf_starter_cleanup
*    cleanup the server instrumentation library
* 
********************************************************************/
extern void y_vnf_starter_cleanup (void);


/* ---------------- LEVI ------------------ */
/*
 * This process returns startup parameters set in startup.xml
 * const xmlChar* element - needed element, e.g., y_vnf_starter_N_agent_name
 * return gchar* - value defined in the found element, if not found it returns
 * NULL
 */
gchar* y_vnf_starter_get_startup_parameter(const xmlChar* element);

/*
 * This process is devoted to get a port from the available ports.
 * Basically, it reads the last element in the available_ports list, and then
 * removes it from the list
 * return gchar* - A port
 */
gchar* y_vnf_starter_get_a_port(void);


/*
 * This helper function gets a vnf's data and returns it as a xml_list for
 * RPC-REPLY of getVNFInfo
 * gchar* vnf_id - the id of the vnf
 * returns val_value_t* - the list of a vnf's data
 */
val_value_t* y_vnf_starter_get_initiated_vnf_data(status_t res, gchar* vnf_id);

/* -------------- END LEVI ----------------- */

#ifdef __cplusplus
} /* end extern 'C' */
#endif

#endif
