
/* 
 * Copyright (c) 2008-2012, Andy Bierman, All Rights Reserved.
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *

*** Generated by yangdump 2.2-5

    Combined SIL module
    module starter
    revision 2013-03-13
    namespace http://csikor.tmit.bme.hu/netconf/unify/starter
    organization BME-TMIT

 */

#include <xmlstring.h>
/*********** LEVI *******************/
/* in order to create new processes */
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
/************************************/
#include "procdefs.h"
#include "agt.h"
#include "agt_cb.h"
#include "agt_not.h"
#include "agt_rpc.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "dlq.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "rpc.h"
#include "ses.h"
#include "status.h"
#include "val.h"
#include "val_util.h"
#include "xml_util.h"
#include "starter.h"

/* module static variables */
static ncx_module_t *starter_mod;
static obj_template_t *starter_obj;
static obj_template_t *starter_start_vnf_obj;
static obj_template_t *starter_kill_vnf_obj;
static obj_template_t *starter_get_load_obj;
static obj_template_t *starter_get_processes_obj;
static obj_template_t *processData_obj;
static obj_template_t *processDone_obj;
static val_value_t *starter_val;

/* put your static variables here */
static int uniqueID = 0;
typedef struct process
{
	int uniqueID;
	char* name;
	int pid;
}process;
static process process_array[100];

/********************************************************************
* FUNCTION y_starter_init_static_vars
* 
* initialize module static variables
* 
********************************************************************/
static void y_starter_init_static_vars (void)
{
    starter_mod = NULL;
    starter_obj = NULL;
    starter_start_vnf_obj = NULL;
    starter_kill_vnf_obj = NULL;
    starter_get_load_obj = NULL;
    starter_get_processes_obj = NULL;
    processData_obj = NULL;
    processDone_obj = NULL;
    starter_val = NULL;

    /* init your static variables here */

} /* y_starter_init_static_vars */


/********************************************************************
* FUNCTION starter_starter_appName_edit
* 
* Edit database object callback
* Path: /starter/appName
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t starter_starter_appName_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter starter_starter_appName_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* starter_starter_appName_edit */


/********************************************************************
* FUNCTION starter_starter_appParams_edit
* 
* Edit database object callback
* Path: /starter/appParams
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t starter_starter_appParams_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter starter_starter_appParams_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* starter_starter_appParams_edit */


/********************************************************************
* FUNCTION starter_starter_capabilities_edit
* 
* Edit database object callback
* Path: /starter/capabilities
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t starter_starter_capabilities_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter starter_starter_capabilities_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* starter_starter_capabilities_edit */


/********************************************************************
* FUNCTION starter_starter_edit
* 
* Edit database object callback
* Path: /starter
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t starter_starter_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter starter_starter_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }

        if (res == NO_ERR) {
            res = agt_check_cache(&starter_val, newval, curval, editop);
        }
        
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* starter_starter_edit */


/********************************************************************
* FUNCTION y_starter_starter_start_vnf_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_starter_starter_start_vnf_validate (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode)
{
    status_t res = NO_ERR;
    val_value_t *errorval = NULL;

    val_value_t *port_val;
    const xmlChar *port;
    val_value_t *clickDescription_val;
    const xmlChar *clickDescription;

    port_val = val_find_child(
        msg->rpc_input,
        y_starter_M_starter,
        y_starter_N_port);
    if (port_val != NULL && port_val->res == NO_ERR) {
        port = VAL_STRING(port_val);
    }

    clickDescription_val = val_find_child(
        msg->rpc_input,
        y_starter_M_starter,
        y_starter_N_clickDescription);
    if (clickDescription_val != NULL && clickDescription_val->res == NO_ERR) {
        clickDescription = VAL_STRING(clickDescription_val);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_OPERATION,
            res,
            methnode,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* y_starter_starter_start_vnf_validate */


/********************************************************************
* FUNCTION y_starter_starter_start_vnf_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_starter_starter_start_vnf_invoke (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode)
{
    status_t res = NO_ERR;

    val_value_t *port_val;
    const xmlChar *port;
    val_value_t *clickDescription_val;
    const xmlChar *clickDescription;

    port_val = val_find_child(
        msg->rpc_input,
        y_starter_M_starter,
        y_starter_N_port);
    if (port_val != NULL && port_val->res == NO_ERR) {
        port = VAL_STRING(port_val);
    }

    clickDescription_val = val_find_child(
        msg->rpc_input,
        y_starter_M_starter,
        y_starter_N_clickDescription);
    if (clickDescription_val != NULL && clickDescription_val->res == NO_ERR) {
        clickDescription = VAL_STRING(clickDescription_val);
    }

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if methnode is used */
    (void)methnode;

    /* invoke your device instrumentation code here */
          /*********************** THIS PART IS ADDED MANUALLY BY LEVI *************************/
	log_info("\nStart VNF RPC is invoked with the following settings: \n");
	log_info("\n%s",clickDescription);
	

	int processID;
	int status;

		
	log_info("\nFORKING\n");
	
	
	/* in order to avoid block main thread 
	   otherwise, yangcli also waits for 
	   termination of child process */
	signal(SIGCHLD, SIG_IGN);
		
	
	if((processID = fork() == 0 ))
	{
		/*	the child process	*/
		
		log_info("\nPID of child: %d ",getpid());
		/*lastProcess.name = "sleep";
		lastProcess.pid = getpid();*/
		
		//dumping data into the processes_array
		process p;
		p.uniqueID = uniqueID;
		p.name = "click";
		p.pid = getpid();
		process_array[uniqueID]=p;
		uniqueID++;
		
		
		log_info("\nPID of netconfd: %d ", getppid());
		
		
		// setting up the default params for starting click
		char control_socket[3] = "-R";
		char port_param[8] = "-p";
		strcat(port_param,(char*)port);
		char p3[3] = "-e";
/*		char p4[100] = "FromDevice(eth1)->Discard;";*/
		char click_path[100]="/home/unify/click_binaries/bin/click";
		
		int errorCode = execlp(click_path, click_path, control_socket, port_param, p3, clickDescription, NULL);
		
		
		/* if everything went fine, we do not reach this point */
		log_info("\nThe result of the execution is %d", errorCode);
		_exit(127);		
		
	} 
	else 
	{ 		
  		log_info("\n\n--------------- RPC END ------------------\n\n");
	}

    /********************************** END OF LEVI **************************************/
    return res;

} /* y_starter_starter_start_vnf_invoke */


/********************************************************************
* FUNCTION y_starter_starter_kill_vnf_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_starter_starter_kill_vnf_validate (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode)
{
    status_t res = NO_ERR;
    val_value_t *errorval = NULL;

    val_value_t *vnfID_val;
    const xmlChar *vnfID;

    vnfID_val = val_find_child(
        msg->rpc_input,
        y_starter_M_starter,
        y_starter_N_vnfID);
    if (vnfID_val != NULL && vnfID_val->res == NO_ERR) {
        vnfID = VAL_STRING(vnfID_val);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_OPERATION,
            res,
            methnode,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* y_starter_starter_kill_vnf_validate */


/********************************************************************
* FUNCTION y_starter_starter_kill_vnf_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_starter_starter_kill_vnf_invoke (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode)
{
    status_t res = NO_ERR;

    val_value_t *vnfID_val;
    const xmlChar *vnfID;

    vnfID_val = val_find_child(
        msg->rpc_input,
        y_starter_M_starter,
        y_starter_N_vnfID);
    if (vnfID_val != NULL && vnfID_val->res == NO_ERR) {
        vnfID = VAL_STRING(vnfID_val);
    }

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if methnode is used */
    (void)methnode;

    /* invoke your device instrumentation code here */
    
    return res;

} /* y_starter_starter_kill_vnf_invoke */


/********************************************************************
* FUNCTION y_starter_starter_get_load_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_starter_starter_get_load_validate (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode)
{
    status_t res = NO_ERR;
    val_value_t *errorval = NULL;


    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_OPERATION,
            res,
            methnode,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* y_starter_starter_get_load_validate */


/********************************************************************
* FUNCTION y_starter_starter_get_load_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_starter_starter_get_load_invoke (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode)
{
    status_t res = NO_ERR;


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if msg is used */
    (void)msg;

    /* remove the next line if methnode is used */
    (void)methnode;

    /* invoke your device instrumentation code here */
    /*********************** THIS PART IS ADDED MANUALLY BY LEVI *************************/ 
	//--------- GET LOAD DATA ----------------
	//it looks like this: "0.01 0.14 0.12 1/309 6531"
	FILE *fp;
	int status;
	char load[30];
	
	//open the command for reading
	fp = popen("cat /proc/loadavg", "r");
	if(fp == NULL)
	{
		log_info("\nFailed to get LOAD\n");
			
	}
	else 
	{
		while(fgets(load, sizeof(load)-1, fp) != NULL)
		{
			log_info("\nRead data from cli: %s\n", load);		
		}	
		
		//closing
		pclose(fp);
	}
	//##########################################
	  
	  int numberOfLoadParams = 5;
	  char *load_params[numberOfLoadParams];
	  int n=0;
	  int nn;
	  
	  char *ds = strdup(load);
	  
	  load_params[n]=strtok(ds, " ");
	  //log_info("load_params[%d]:%s",n,load_params[n]);
	  while(load_params[n] && (n < (numberOfLoadParams-1)))
	  {
			load_params[++n] = strtok(NULL, " ");
//			log_info("[LOG]load_params[%d]:%s",n,load_params[n]);
	  }
	  
	  	
	 	
    
		val_value_t *childval = NULL;
    	childval = agt_make_list(
    				obj_find_child(starter_get_load_obj,y_starter_M_starter,"output"),
    				y_starter_N_load,
    				&res);
		if(childval != NULL)
		{
			log_info("\nList found and initialized");		
		}
		
		val_value_t *a = NULL;
/*		char loadOne[40] = "load_One";*/
		a = agt_make_leaf(
			childval->obj,
			y_starter_N_loadOne,
			(const xmlChar*)load_params[0],
			&res);
		if(a!=NULL)
		{
			log_info("\nloadOne filled with ");
			log_info(load_params[0]);

			val_add_child(a,childval);		
		}
		else 
		{
			return res;		
		}
		
		
/*		char loadFive[40] = "load_Five";*/
		a = agt_make_leaf(
			childval->obj,
			y_starter_N_loadFive,
			(const xmlChar*)load_params[1],
			&res);
		if(a!=NULL)
		{
			log_info("\nloadFive filled with ");
			log_info(load_params[1]);

			val_add_child(a,childval);		
		}
		else 
		{
			return res;		
		}
		
		
/*		char loadFifteen[40] = "load_Fifteen";*/
		a = agt_make_leaf(
			childval->obj,
			y_starter_N_loadFifteen,
			(const xmlChar*)load_params[2],
			&res);
		if(a!=NULL)
		{
			log_info("\nloadFifteen filled with ");
			log_info(load_params[2]);

			val_add_child(a,childval);		
		}
		else 
		{
			return res;		
		}
		
/*		char processesCE[40] = "processesCurrentlyExists";*/
		a = agt_make_leaf(
			childval->obj,
			y_starter_N_processesCurrentlyExists,
			(const xmlChar*)load_params[3],
			&res);
		if(a!=NULL)
		{
			log_info("\nprocessesCE filled with ");
			log_info(load_params[3]);

			val_add_child(a,childval);		
		}
		else 
		{
			return res;		
		}
		
		/*log_info("PID: %s", load_params[4]);*/
		//we need to remove the trailing \n from the end
		char* pid = strtok(load_params[4],"\n");
		a = agt_make_leaf(
			childval->obj,
			y_starter_N_pid,
			(const xmlChar*)pid,
			&res);
		if(a!=NULL)
		{
			log_info("\npid filled with ");
			log_info(pid);

			val_add_child(a,childval);		
		}
		else 
		{
			return res;		
		}

		free(ds);

		dlq_enque((void*)childval,&(msg->rpc_dataQ));

/*	 // ------------------------ CREATING A CUSTOM RPC REPLY -------------------------------
	
	 //declare a val_value_t * paramter   
    val_value_t *rpc_output = NULL;
    //making a leaf
    //	1.param -> we need to find the corresponding output element defined in the yang
    //		starter_get_load_obj is created automatically, since we have a get_load rpc in our module called starter -> starter_get_load_obj
    //		y_starter_M_starter corresponds to the module (you need to modify both strings 'starter' to your module name)
    //		"output" -> is the output part of the rpc (leave unmodified)
    //	2.param -> y_yourModuleName_N_leafNodeInYourRPCOUTPUT
    //	3.param -> the message you want to send (should be xmlChar*, char, char*)
    //	4. param -> the res variable which is returned by default 
	 rpc_output = agt_make_leaf(
	 		obj_find_child(starter_get_load_obj,y_starter_M_starter,"output"),
	 		y_starter_N_load,	
	 		load,
	 		&res);
	
	 //check that we could create correctly our RPC reply message
	 if (rpc_output!=NULL)
    {
    	//if yes -> put that to the rpc-reply (only rpc_output variable should be modified)
		dlq_enque((void*)rpc_output,&(msg->rpc_dataQ));
    }
    //if, however, something went wrong during creating rpc-reply, we print it into the log
    else 
    {
        log_error(
            "\nError: make leaf failed (%s), cannot send "
            "<load> rpc_reply",
            get_error_string(res));
    } 
    //======================================================================================   */
   
    /********************************** END OF LEVI **************************************/
    return res;

} /* y_starter_starter_get_load_invoke */


/********************************************************************
* FUNCTION y_starter_starter_get_processes_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_starter_starter_get_processes_validate (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode)
{
    status_t res = NO_ERR;
    val_value_t *errorval = NULL;


    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_OPERATION,
            res,
            methnode,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* y_starter_starter_get_processes_validate */


/********************************************************************
* FUNCTION y_starter_starter_get_processes_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_starter_starter_get_processes_invoke (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode)
{
    status_t res = NO_ERR;


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if msg is used */
    (void)msg;

    /* remove the next line if methnode is used */
    (void)methnode;

    /* invoke your device instrumentation code here */
    
    return res;

} /* y_starter_starter_get_processes_invoke */


/********************************************************************
* FUNCTION y_starter_processData_send
* 
* Send a y_starter_processData notification
* Called by your code when notification event occurs
* 
********************************************************************/
void y_starter_processData_send (
    const xmlChar *processName,
    int32 processID)
{
    agt_not_msg_t *notif;
    val_value_t *parmval;
    status_t res = NO_ERR;


    if (LOGDEBUG) {
        log_debug("\nGenerating <processData> notification");
    }
    
    notif = agt_not_new_notification(processData_obj);
    if (notif == NULL) {
        log_error("\nError: malloc failed, cannot send "
        "<processData> notification");
        return;
    }
    
    /* add processName to payload */
    parmval = agt_make_leaf(
        processData_obj,
        y_starter_N_processName,
        processName,
        &res);
    if (parmval == NULL) {
        log_error(
            "\nError: make leaf failed (%s), cannot send "
            "<processData> notification",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }
    
    /* add processID to payload */
    parmval = agt_make_int_leaf(
        processData_obj,
        y_starter_N_processID,
        processID,
        &res);
    if (parmval == NULL) {
        log_error(
            "\nError: make leaf failed (%s), cannot send "
            "<processData> notification",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }
    
    agt_not_queue_notification(notif);
    
} /* y_starter_processData_send */


/********************************************************************
* FUNCTION y_starter_processDone_send
* 
* Send a y_starter_processDone notification
* Called by your code when notification event occurs
* 
********************************************************************/
void y_starter_processDone_send (
    const xmlChar *processStatus,
    const xmlChar *etc)
{
    agt_not_msg_t *notif;
    val_value_t *parmval;
    status_t res = NO_ERR;


    if (LOGDEBUG) {
        log_debug("\nGenerating <processDone> notification");
    }
    
    notif = agt_not_new_notification(processDone_obj);
    if (notif == NULL) {
        log_error("\nError: malloc failed, cannot send "
        "<processDone> notification");
        return;
    }
    
    /* add processStatus to payload */
    parmval = agt_make_leaf(
        processDone_obj,
        y_starter_N_processStatus,
        processStatus,
        &res);
    if (parmval == NULL) {
        log_error(
            "\nError: make leaf failed (%s), cannot send "
            "<processDone> notification",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }
    
    /* add etc to payload */
    parmval = agt_make_leaf(
        processDone_obj,
        y_starter_N_etc,
        etc,
        &res);
    if (parmval == NULL) {
        log_error(
            "\nError: make leaf failed (%s), cannot send "
            "<processDone> notification",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }
    
    agt_not_queue_notification(notif);
    
} /* y_starter_processDone_send */

/********************************************************************
* FUNCTION y_starter_init
* 
* initialize the starter server instrumentation library
* 
* INPUTS:
*    modname == requested module name
*    revision == requested version (NULL for any)
* 
* RETURNS:
*     error status
********************************************************************/
status_t y_starter_init (
    const xmlChar *modname,
    const xmlChar *revision)
{
    status_t res = NO_ERR;
    agt_profile_t *agt_profile = agt_get_profile();

    y_starter_init_static_vars();

    /* change if custom handling done */
    if (xml_strcmp(modname, y_starter_M_starter)) {
        return ERR_NCX_UNKNOWN_MODULE;
    }

    if (revision && xml_strcmp(revision, y_starter_R_starter)) {
        return ERR_NCX_WRONG_VERSION;
    }
    res = ncxmod_load_module(
        y_starter_M_starter,
        y_starter_R_starter,
        &agt_profile->agt_savedevQ,
        &starter_mod);
    if (res != NO_ERR) {
        return res;
    }

    starter_obj = ncx_find_object(
        starter_mod,
        y_starter_N_starter);
    if (starter_mod == NULL) {
        return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
    }
    starter_start_vnf_obj = ncx_find_object(
        starter_mod,
        y_starter_N_starter_start_vnf);
    if (starter_mod == NULL) {
        return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
    }
    starter_kill_vnf_obj = ncx_find_object(
        starter_mod,
        y_starter_N_starter_kill_vnf);
    if (starter_mod == NULL) {
        return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
    }
    starter_get_load_obj = ncx_find_object(
        starter_mod,
        y_starter_N_starter_get_load);
    if (starter_mod == NULL) {
        return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
    }
    starter_get_processes_obj = ncx_find_object(
        starter_mod,
        y_starter_N_starter_get_processes);
    if (starter_mod == NULL) {
        return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
    }
    processData_obj = ncx_find_object(
        starter_mod,
        y_starter_N_processData);
    if (starter_mod == NULL) {
        return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
    }
    processDone_obj = ncx_find_object(
        starter_mod,
        y_starter_N_processDone);
    if (starter_mod == NULL) {
        return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
    }
    res = agt_rpc_register_method(
        y_starter_M_starter,
        y_starter_N_starter_start_vnf,
        AGT_RPC_PH_VALIDATE,
        y_starter_starter_start_vnf_validate);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_starter_M_starter,
        y_starter_N_starter_start_vnf,
        AGT_RPC_PH_INVOKE,
        y_starter_starter_start_vnf_invoke);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_starter_M_starter,
        y_starter_N_starter_kill_vnf,
        AGT_RPC_PH_VALIDATE,
        y_starter_starter_kill_vnf_validate);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_starter_M_starter,
        y_starter_N_starter_kill_vnf,
        AGT_RPC_PH_INVOKE,
        y_starter_starter_kill_vnf_invoke);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_starter_M_starter,
        y_starter_N_starter_get_load,
        AGT_RPC_PH_VALIDATE,
        y_starter_starter_get_load_validate);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_starter_M_starter,
        y_starter_N_starter_get_load,
        AGT_RPC_PH_INVOKE,
        y_starter_starter_get_load_invoke);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_starter_M_starter,
        y_starter_N_starter_get_processes,
        AGT_RPC_PH_VALIDATE,
        y_starter_starter_get_processes_validate);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_starter_M_starter,
        y_starter_N_starter_get_processes,
        AGT_RPC_PH_INVOKE,
        y_starter_starter_get_processes_invoke);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_starter_M_starter,
        (const xmlChar *)"/starter",
        y_starter_R_starter,
        starter_starter_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_starter_M_starter,
        (const xmlChar *)"/starter/appName",
        y_starter_R_starter,
        starter_starter_appName_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_starter_M_starter,
        (const xmlChar *)"/starter/appParams",
        y_starter_R_starter,
        starter_starter_appParams_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_starter_M_starter,
        (const xmlChar *)"/starter/capabilities",
        y_starter_R_starter,
        starter_starter_capabilities_edit);
    if (res != NO_ERR) {
        return res;
    }

    /* put your module initialization code here */
    
    return res;
} /* y_starter_init */

/********************************************************************
* FUNCTION y_starter_init2
* 
* SIL init phase 2: non-config data structures
* Called after running config is loaded
* 
* RETURNS:
*     error status
********************************************************************/
status_t y_starter_init2 (void)
{
    status_t res = NO_ERR;

    starter_val = agt_init_cache(
        y_starter_M_starter,
        y_starter_N_starter,
        &res);
    if (res != NO_ERR) {
        return res;
    }

    /* put your init2 code here */

    return res;
} /* y_starter_init2 */

/********************************************************************
* FUNCTION y_starter_cleanup
*    cleanup the server instrumentation library
* 
********************************************************************/
void y_starter_cleanup (void)
{
    
    agt_rpc_unregister_method(
        y_starter_M_starter,
        y_starter_N_starter_start_vnf);
    
    agt_rpc_unregister_method(
        y_starter_M_starter,
        y_starter_N_starter_kill_vnf);
    
    agt_rpc_unregister_method(
        y_starter_M_starter,
        y_starter_N_starter_get_load);
    
    agt_rpc_unregister_method(
        y_starter_M_starter,
        y_starter_N_starter_get_processes);
    agt_cb_unregister_callbacks(
        y_starter_M_starter,
        (const xmlChar *)"/starter");

    agt_cb_unregister_callbacks(
        y_starter_M_starter,
        (const xmlChar *)"/starter/appName");

    agt_cb_unregister_callbacks(
        y_starter_M_starter,
        (const xmlChar *)"/starter/appParams");

    agt_cb_unregister_callbacks(
        y_starter_M_starter,
        (const xmlChar *)"/starter/capabilities");

    /* put your cleanup code here */
    
} /* y_starter_cleanup */

/* END starter.c */
